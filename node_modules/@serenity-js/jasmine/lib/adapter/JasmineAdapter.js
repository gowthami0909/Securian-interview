"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JasmineAdapter = void 0;
const index_js_1 = require("@serenity-js/core/lib/model/index.js");
const index_js_2 = __importDefault(require("../index.js"));
const index_js_3 = require("./filters/index.js");
/**
 * Allows for programmatic execution of Jasmine test scenarios,
 * using [`SerenityReporterForJasmine`](https://serenity-js.org/api/jasmine/function/default/) to report progress.
 *
 * ## Learn more
 * - [`TestRunnerAdapter`](https://serenity-js.org/api/core-adapter/interface/TestRunnerAdapter/)
 *
 * @group Integration
 */
class JasmineAdapter {
    config;
    loader;
    runner;
    totalScenarios = 0;
    static defaultConfig = {
        /*
         * Serenity/JS doesn't use Jasmine's assertions, so this mechanism can be disabled
         */
        oneFailurePerSpec: true,
        /*
         * A spec should stop execution as soon as there's a hook or spec failure
         * See https://github.com/angular/protractor/issues/3234
         */
        stopSpecOnExpectationFailure: true,
        /*
         * Default to not executing tests at random.
         * See https://github.com/angular/protractor/blob/4f74a4ec753c97adfe955fe468a39286a0a55837/lib/frameworks/jasmine.js#L76
         */
        random: false,
    };
    constructor(config, loader) {
        this.config = config;
        this.loader = loader;
    }
    /**
     * Scenario success threshold for this test runner.
     */
    successThreshold() {
        return index_js_1.ExecutionIgnored;
    }
    /**
     * Loads test scenarios.
     *
     * @param pathsToScenarios
     */
    async load(pathsToScenarios) {
        const JasmineRunner = this.loader.require('jasmine');
        this.runner = new JasmineRunner({ projectBaseDir: '' });
        if (this.config.defaultTimeoutInterval) {
            this.runner.jasmine.DEFAULT_TIMEOUT_INTERVAL = this.config.defaultTimeoutInterval;
        }
        this.runner.clearReporters();
        this.runner.loadConfig(Object.assign(JasmineAdapter.defaultConfig, this.config));
        const reporterConfig = this.config.specDir ? { specDirectory: this.config.specDir } : {};
        this.runner.addReporter((0, index_js_2.default)(reporterConfig, this.runner.jasmine));
        if (this.config.reporters) {
            this.config.reporters.forEach(reporter => {
                this.runner.addReporter(reporter);
            });
        }
        this.runner.configureDefaultReporter(this.config);
        this.runner.loadRequires();
        this.runner.loadHelpers();
        this.configureSpecFilter();
        await this.loadSpecs(pathsToScenarios);
        this.countScenarios(this.runner.env.topSuite());
    }
    configureSpecFilter() {
        /*
         * Configure spec filter
         */
        this.runner.env.configure({
            specFilter: spec => this.specFilter().matches(spec.getFullName()),
        });
    }
    async loadSpecs(pathsToScenarios) {
        this.runner.specDir = '';
        this.runner.specFiles = [];
        this.runner.addMatchingSpecFiles(pathsToScenarios);
        await this.runner.loadSpecs();
    }
    specFilter() {
        if (this.config.specFilter) {
            return new index_js_3.CustomFunctionSpecFilter(this.config.specFilter);
        }
        if (this.config.grep) {
            return this.config.invertGrep
                ? new index_js_3.InvertedGrepSpecFilter(this.config.grep)
                : new index_js_3.GrepSpecFilter(this.config.grep);
        }
        return new index_js_3.AcceptingSpecFilter();
    }
    /**
     * Returns the number of loaded scenarios
     */
    scenarioCount() {
        return this.totalScenarios;
    }
    countScenarios(suite) {
        suite.children?.forEach((child) => {
            if (Array.isArray(child.children)) {
                return this.countScenarios(child);
            }
            if (this.specFilter().matches(child.getFullName())) {
                this.totalScenarios++;
            }
        });
    }
    /**
     * Runs loaded test scenarios.
     */
    async run() {
        this.runner.exitOnCompletion = false;
        await this.runner.execute();
    }
}
exports.JasmineAdapter = JasmineAdapter;
//# sourceMappingURL=JasmineAdapter.js.map